This file documents hot keys for playing music on the Raspberry pi,
though it is applicable to other platforms.
And the hot keys need not be jupiter based, you could use esekeyd for example,
or write your own program in user space to intercept keystrokes and take action.

It began in 2008 when we bought the mac, one of the best computers I ever owned,
relative to the needs of my sighted family.
Pricy - but it was easy to use,
more intuitive than today's computers and cell phones, and it lasted a long time.
The keyboard had three keys at the upper right, which have since become standard.
Those keys raised and lowered volume, and paused the music.
You could be off in another application, doing homework, browsing the net, playing a game,
and still the music was always at your fingertips.
The phone rings - just hit pause.
someone comes in and wants to chat - lower the volume.
You don't have to switch to another tab or change context.
I wanted this capability on my computers.

jupiter's config file supports a pipe syntax to run a command.
So the conceptual idea is:

sysrq|lower volume
scroll|raise volume
pause|pause music

Now those three buttons act just like the Mac.
I can be on some other console,working on a project,
and the music is still at my fingertips.
But how to implement?

Volume is controlled by /usr/bin/amixer,
and that program seems to change its syntax with every release.
It can be frustrating - but I read the man page,
determine the new syntax, and update jupiter's config file accordingly.
It's a minor maintenance every few years.
Here is the syntax that works on Raspbian 12 bookworm.
Your mileage may vary.

sysrq|amixer -q set Master 3%-
scroll|amixer -q set Master 3%+

A couple of aliases in .bashrc can read and set the volume.

alias auvol="amixer get Master | sed -e '/%/!d' -e '/Right/d' -e 's/%].*//' -e 's/.* \[//'"
alias auset="amixer -q set Master 60%"

Press the hot keys, volume up and down, and verify by auvol
that the volume is indeed changing.
Or try it while music is playing.

But there's another problem.
I naturally play music under my account, as a user, and once pipewire is launched,
root has no access to the mixer, or to the music programs in general,
such as play or mpg123 or mpv.
This was not a problem in earlier versions of Raspbian, but it is now.
And it seems to be insurmountable.
Therefore, jupiter cannot run as root.
In fact it must run as me.
Not just to access the mixer, but to access the sound card in general, for speech.
I use an external hardware synthesizer, but most people don't.
Most people use a software synth, such as espeakup,
so you have to have access to the sound card, else the computer remains silent.

By default, debian users belong to the audio group.
Type id to see which groups you belong to.
If you are not in the audio group, run this command.

usermod -a -G audio yourLogin

To run the adapter as me,
root has to su to me when it launches jupiter,
thence jupiter can speak through the sound card,
and it can, in parallel, control the hot keys to raise and lower volume.

Note that amixer controls over all volume,
while the volume of speech is handled by internal jupiter commands.
Thus you can control the volume of jupiter speech relative to your music,
and then you can control the overall volume.

+f1 decvol
+f2 incvol
sysrq|amixer -q set Master 3%-
scroll|amixer -q set Master 3%+

Here is my rc.local file that launches jupiter under my user account eklhad.
The first line has to be this or it won't run.

#!/bin/sh -e
# create debug file in my name
touch /var/log/acslog ; chmod 666 /var/log/acslog
# I use a hardware synth on the serial port through a usb serial converter.
su -c "XDG_RUNTIME_DIR=/run/user/1000 /usr/local/bin/jupiter -d dbe u0 >/tmp/jupiter.log 2>&1" eklhad

The XDG variable is important here.
XDG_RUNTIME_DIR tells amixer where to find the pid of the running pipewire daemon.
It can't figure it out from my id alone.
But if XDG doesn't match my id, (eklhad = 1000), it prints an error and exits.
so you'd think it would just find the runtime directory for my account and move on, but no.
I have to explicitly set XDG_RUNTIME_DIR in jupiter's environment.

Now let's return to the pause button, which we have not addressed yet.
jupiter is a daemon process running in the background, and mpg123 (for example)
is a music player running under a console, in my case console 11.
If I happen to be in console 11, where the music is, I can hit space to pause and resume,
or other action keys, but I am almost always somewhere else.
In console 7 for example, writing this documentation.
Somehow the pause button must launch a program that communicates with mpg123,
(wherever it is), and send it a space key.

At my request, Thomas Orgis was kind enough to add a feature for me, in 2016,
wherein mpg123 would pause and restart upon signal SIGUSR1.
So all I had to do was killall -s10 mpg123.
That rounds out the three keys.

sysrq|amixer -q set Master 3%-
scroll|amixer -q set Master 3%+
pause|killall -s10 mpg123

Unfortunately this feature broke as of Raspbian 12 bookworm.
I notified Thomas and he fixed it right away. very responsive to his users.
So signal 10 may or may not work for you, depending on your version.
If it works for you then run with it; that is the easiest way to implement a global pause button.
If not, there is another way.

There is a lovely ioctl function that injects keystrokes into another terminal.
I wrote a program to take advantage of this function;
it is injkey.c (inject key) in the jupiter directory.
It's very short; feel free to read it.
make will compile it, and make injkey-install will install it.
The program is setuid root, because ironically, it has to run as root.
So I have to run jupiter as user, to access the sound card,
but then injkey has to run as root.
Not just effective user root but real user root.
This has obvious security risks; so you should only do this
if this is your personal computer, with no other users.
With that in mind, here are the three hot keys.

sysrq|amixer -q set Master 3%-
scroll|amixer -q set Master 3%+
pause|/usr/local/bin/injkey 11 ' '

This assumes console 11 is devoted to music;
you may do things differently.

this is not limited to pause.
You can inject other characters (see man mpg123).
You can set hot keys to restart the song, jump to the previous song,
jump to the next song, skip ahead or back, etc.
As many hot keys as you care to dedicate to music -
although these are no longer available for your speech functions or other capabilities.
Remember to run mpg123 -q -C, for quiet mode and character response.
Or use this alias.
alias mplay="mpg123 -q -C"
Here are three more keys assigned to previous song, restart song, next song.

k110|/usr/local/bin/injkey 11 d
k102|/usr/local/bin/injkey 11 b
k104|/usr/local/bin/injkey 11 f

We would not need the injkey command if mpg123 --fifo worked.
That is a superior approach in many ways, but I can't get it to work
as documented, so I am using injkey.

Since I developed the "next song" button, I have become pickier in my music.
“Nah. I'm not in the mood for that song right now. Next!”

Whether by injkey or --fifo,
the "previous song" command, character d, only works if you are playing
an album, or a set of songs as arguments to mpg123.
In other words, mpg123 has to have a song to back up to.
If it is on the first song, or there is only one song as argument, it starts that song again.
Thus the backup key isn't meaningful for a song provider that plays songs at random.
It executes mpg123 on each song in turn, one argument, and there is no way to back up.
You can however go forward, because the f key ends the list,
and mpg123 exits, whence your song server selects the next song.
Desiring the backup feature, I made an enhancement to my jbrad program,
found in this directory.
It remembers the last 5 songs that it played and hands them to mpg123 as arguments,
then it jumps to the ultimate (current) song by feeding f's to the program through injkey.
Now the backup key works, through the last 5 songs anyways.
This is not vital to anyone's existence, it was primarily a fun programming exercise.

Another hot key could print or speak artist, album, and song.
k107|/usr/local/bin/artist 11 p
See the artist shell script in this directory.

The hot keys, vectoring through injkey, are not limited to mpg123.
If you prefer mpv, you can write hot keys to control that program instead.
Read the man page to see what keys elicit what responses.

mpv has a nice feature that mpg123 lacks.
The bracket keys increase and decrease speed, without changing pitch.
This is a difficult mathematical transform, and they do it well.
Obviously you don't want to listen to music this way,
but it can be helpful if your podcast is a bit slow, and you want to move it along.
If you want mpv to emulate mpg123 in other respects, then do the following.
Create the directory $HOME/.config/mpv
Within that directory, create mpv.conf, containing:

no-video
really-quiet

Create input.conf, containing:

1 seek 0 absolute-percent
2 seek 10 absolute-percent
3 seek 20 absolute-percent
4 seek 30 absolute-percent
5 seek 40 absolute-percent
6 seek 50 absolute-percent
7 seek 60 absolute-percent
8 seek 70 absolute-percent
9 seek 80 absolute-percent
0 seek 90 absolute-percent
, seek -0.5 relative
. seek +0.5 relative
; seek -2.0 relative
: seek +2.0 relative
b seek 0 absolute-percent
d playlist-prev
f playlist-next
l show-text "> ${filename}"

The l command doesn't work; you have to change really-quiet to quiet so mpv
will display something, and even then I can't seem to find it on the screen.
Other than that, it's a faithful simulation,
thence the hot keys you have set up for mpg123 will also work interchangeably with mpv.

On my pi, mpv has micropauses, while mpg123 is smoother.
Most people wouldn't notice, or care,
but as a music afficionado, i prefer mpg123 for music.
Thus jbrad invokes that program.
mpv plays my podcasts, wherein I can increase speed as much as 50%,
and assimilate the material faster.

You might want to have music softly playing in the background all the time.
Consider this scenario, which has happened to me more than once.
I am away from my computer for several hours, and when I return to it, it doesn't talk.
I press certain keys and it doesn't read anything.
Was there a kernel panic, or a power failure that lasted longer than my UPS could carry?
No - because the music is still playing. The computer is still up and running.
Next, I test the hot keys that control the music.
Can I turn the volume up and down?
If yes then the adapter is still running.
If no then the adapter has crashed, and I need to restart it.
It is a software program, and like any other program, a corner case can bring it down.
On one occasion things were even stranger.
I could control the music but still it wouldn't speak.
I turned my synthesizer on and off, and still it wouldn't speak.
Finally I unplugged the usb serial cable and plugged it back in.
That did the trick.
But it would have been much harder to debug without the music.

In a perfect world, a podcast episode is contained in a local mp3 file,
whence you can use mpg123 or mpv, and all the hot keys that you have set up.
The podgo script, in this directory, fetches podcast episodes as mp3 files,
according to your sources, which you place in pod.conf.
See the script, and sample-pod.conf, for more information.
