<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<META name=description content="jupiter documentation, a linear adapter for the blind.">
<meta name=keywords content="
text based, command line, interactive, linear,
adapter, speech, blind, customizable">
<title>Jupiter Documentation</title>
<style>
body {
background: white;
color: black;
font-family: Arial,Helvetica,sans-serif;
font-size: 100%;
}
h1 {
text-align: center;
font-size: 2.5em;
color: navy;
}
h2 {
text-align: center;
font-size: 2.0em;
color: darkslateblue;
}
p.cen {
font-size: 1.5em;
text-align: center;
}
hr {
border: 3px solid blue;
}
a:link { color: red; font-size: 1.25em; }
a:visited { color: red; font-size: 1.25em; }
a:hover { color: red; font-size: 1.25em; }
a:active { color: red; font-size: 1.25em; }
</style>
</head>
<body>

<h1>Jupiter Documentation: a user's guide</h1>

<h2 id=top>Contents</h2>

<ul>
<li><a href=#auth>Author</a>
<li><a href=#copy>Copyright Notice</a>
<li><a href=#over>Overview</a>
<li><a href=#lang>Other Languages</a>
<li><a href=#mod>Modules</a>
<li><a href=#install>Installation</a>
<li><a href=#options>Command-line options</a>
<li><a href=#syn>Synthesizers</a>
<li><a href=#run>Running at boot</a>
<li><a href=#modes>Modes</a>
<li><a href=#cfg>Config Files</a>
<li><a href=#rc>The Reading Cursor and Atomic Commands</a>
<li><a href=#vc>The Visual Cursor and Autoread</a>
<li><a href=#cfs>Config File Syntax</a>
<li><a href=#fifo>Jupiter fifo</a>
<li><a href=#sum>Summary</a>
</ul>

<h2 id=auth>Author</h2>

<p>
Karl Dahlke
<a href=mailto:eklhad@gmail.com>eklhad@gmail.com</a>

<h2 id=copy>Copyright notice</h2>

<p>
This program is copyright &copy; Karl Dahlke, 2000-2025.
It is made available by the author under the terms of the GNU General Public License (GPL),
as articulated by the Free Software Foundation.
It may be used for any purpose, and redistributed, provided this copyright notice is included.

<h2 id=over>Overview</h2>

<p>
Jupiter is unique among all adapters in that it does not (by default) transform the words or icons on the screen into speech or braille.
It is not typically used as a screen reader.
It is capable of reading screen memory
and interacting with certain curses programs,
but it typically runs in linear mode,
capturing all tty output like a paper teletype and making it available to the blind user through speech.
The buffer is 64K, and could represent several hours of work,
depending on the nature and quantity of output during that time.
Or it could represent just a few seconds of output, if a program prints "hello world" in an infinite loop.

<p>
I call this a linear adapter, rather than a screen reader,
because it maintains a linear buffer of tty output,
and allows the blind user to move about within this buffer and read the accumulated text.
This is part of a larger philosophy,
wherein editors, browsers, mail clients, spreadsheets, and other critical applications
are rewritten from the ground up if necessary
to support various disabilities.
Once this is done,
Other applications can leverage these tools,
and be immediately accessible to a wide range of computer users.
You can read more about this
<a href=http://www.eklhad.net/philosophy.html>command line philosophy</a>
here.

<p>
Although Jupiter is interoperable with some curses-based screen programs,
it is incompatible with a graphical desktop such as gnome or kde.
More generally, Jupiter is incompatible with X, which bypasses the traditional tty driver entirely.
Jupiter doesn't see the output, and certainly can't read it to you.
Instead, Jupiter was written for people who spend most of their time at run level 3,
logged into a text based console.
Furthermore, it is most effective when combined with command line programs such as bash,
ls, ssh, mpg123, ed, and of course edbrowse.

<p>
The tty buffers are maintained per console -
thus Jupiter is most effective when combined with the 12 virtual consoles that come standard in Linux,
accessible by alt F1 through alt F12.
Switch to console 7 and you will be reading the tty buffer associated with that console,
i.e. the output of the programs that have been run from that console.
If you use screen(1) to maintain parallel sessions,
the output of all your sessions will intermix in the tty buffer,
and the result will be very confusing.
I therefore recommend 12 or 24 virtual text-based consoles
to manage your parallel sessions.
See bootprocess.txt in this directory to set up these virtual consoles, as they are not there by default.

<h2 id=lang>Other languages</h2>

<p>
The buffer stores tty output in unicode, which is compatible with every language on Earth.
Thus, in theory, Jupiter could be modified to support any language,
provided your speech synthesizer does the same.
At present it supports English, German, and Brazilian Portuguese.
If you are interested in other languages, or if you can help in this effort, please let me know.
You don't have to be a programmer;
you just have to be fluent in your language and conversational in English.
I will do the rest.

<h2 id=mod>Modules</h2>

<p>
Any program can read screen memory from /dev/vcs,
but how do you get your hands on tty output
as it is being generated?
How do you intercept these output characters and store them in a buffer for review?
The answer is a new device driver called /dev/acsint.
Jupiter opens this device driver, and has access to all tty output,
and to the keystrokes that implement speech commands.
In other words, /dev/acsint is the connector between Jupiter and the Linux kernel.

<p>
You must compile and install two modules to bring /dev/acsint to life.
These modules are ttyclicks.ko and acsint.ko.
Unfortunately I can't distribute these modules in binary,
because a separate module must be compiled for each kernel version.
Run `uname -r' to see your kernel version.
If yours is 3.12.3.2, and mine is 3.12.3.1, then my modules won't run on your kernel, and vice versa.
This is intentional,
to prevent the accidental assembly of an inconsistent kernel, but it sometimes gets in the way.
Thus you have to build and install these modules
each time you update your kernel.
That means you have to have the kernel headers, which is an available package,
but rarely loaded by default.
After all, most people don't build the kernel or kernel modules.
But you may have to, as part of the Jupiter installation process,
so make sure you have the headers.
For example:
<br>
sudo apt -q install kernel-headers
<p>
Change to the drivers directory:
<br>
cd drivers
<p>
Configure the acsint driver for your keyboard layout:
<br>
./keyconfigure
<p>
Make the modules:
<br>
make
<p>
Install the modules:
<br>
sudo make modules_install
<p>
You can now leave the drivers directory.
For example, to return to the previous directory:
<br>
cd -
<p>
Tell the modprobe system about the modules:
<br>
sudo depmod -a
<p>
Tell the system to load the acsint modules while booting the system
by putting the word acsint in a file in the
directory /etc/modules-load.d (you only need to do this once).
For example:
<br>
sudo echo acsint &gt; /etc/modules-load.d/access.conf

<p>
complete build and installation instructions can be found in bootprocess.txt


<p>
You'll notice that ttyclicks
generates clicks as output is sent to the screen.
This is exactly what it is suppose to do;
it is the primary function of the ttyclicks module (though it can be disabled with a module parameter).
This can be extremely helpful, especially if your adapter is not running for any reason.
I can tell, by clicks alone, when the computer responds to a command,
and I can discern the quantity and format of that response,
without any speech or braille.
In addition, the output is throttled, and does not fly by the screen
faster than I could possibly hit control S.

<p>
It is important that this be a separate, stand alone kernel module,
apart from anybody's adapter.
If the adapter isn't running,
if the synthesizer isn't working, if the braille display isn't working,
if we're talking to the wrong serial port, if the sound card isn't working,
if the sound card is not properly initialized,
if the sound module is not loaded, if the wrong sound module is loaded,
if an essential daemon is not running - at least I have my clicks.
I can tell, to some degree, what the computer is doing.
If it gets to a login prompt, I know what that sounds like.
I can log in and listen for the single click of the $ prompt,
which tells me I have a shell.
Then I can issue some basic commands,
trying to load modules and start the adapter.
All this I do without speech.
I need these clicks to be present whenever Linux is running.
To this end, ttyclicks is a self-contained module
that is loaded first in the boot sequence.
I can turn off the clicks at run time if I wish,
but if the synthesizer ever fails me for any reason,
I have the clicks to fall back on.

<p>
As you can see from the above paragraph,
I don't want to run these clicks through anybody's sound card.
There are too many points of failure along that path.
Instead, I use the in-built toggle speaker at port 0x61.
Not all computers have this speaker, but most do.
Unfortunately the Raspberry pi does not, and that is now my preferred computer.

<p>
Other programs, outside of the linux kernel, can also take advantage of
this legacy speaker.
Grub, for instance, beeps when it brings up the menu,
provided I put a control G in the first title in grub.conf.
This tells me that I have ten seconds to cursor up and down
and select a target, if I want something other than the default.
Beyond this, it tells me that the machine has gotten to grub successfully,
and is not stuck in bios for some bizarre reason.
Thus a multi-boot system becomes practical.

<p>
This module will not click and chirp if you are in X.
It responds to text characters that pass through the standard tty,
and as mentioned earlier, X bypasses this channel.
Even the terminal emulator running under a desktop still runs through X,
and probably won't work with ttyclicks.
You really need to be in multi-user mode.
Type systemctl get-default to see the run level,
and change it, if need be, like this.

<p>
sudo systemctl set-default multi-user.target

<p>
The ttyclicks module is for command line users,
or users who will stay in command mode long enough to make sure their
software is properly launched and speaking.

<p>
If an output character is an echo of what you typed in, and if it is in upper case, you will hear a high beep instead of a click.
This confirms the fact that you have entered a capital letter.
Thus you receive immediate audio feedback if caps lock is on.
It is quite common for me to hit caps lock by mistake, but I know that it has happened, thanks to the high beeps,
and I hit caps lock again to return to standard typing.
All this audio feedback is at your disposal as long as ttyclicks is installed, whether you run Jupiter or not.

<p>
The clicks have one drawback however;
while output is being generated they monopolize the cpu.
It is hard for other processes to run.
You may find that your music pauses
when a program generates a lot of output.
For a time I tried to patch the kernel to obviate this,
but that became impractical.

<h2 id=install>Installation</h2>

<p>
If you want Jupiter to use the sound card to output various informative sounds,
install the libao-dev package. For example:
<br>
sudo apt -q install libao-dev
<p>
Change to the jupiter directory. For example:
<br>
cd jupiter
<p>
Build Jupiter:
<br>
make
<p>
Install Jupiter:
<br>
sudo make install
<p>
If you want to use the sample config file as your default config file,
copy it to /etc/jupiter/start.cfg:
<br>
sudo cp sample-jupiter.cfg /etc/jupiter/start.cfg

<p>
Again, more complete instructions can be found in bootprocess.txt.

<h2 id=options>Command-line options</h2>

<p>
Run jupiter with the -d option to run it in the background.
This is usually what you want.
While you are deciding how you want to run Jupiter,
particularly which synthesizer arguments to use,
you might want to run Jupiter without the -d option,
so that you can use control C to easily stop Jupiter.

<p>
Run Jupiter with the -a option if you want Jupiter to use the
sound card to output various informative sounds.
Only use this if multiple programs can access the sound card
at the same time on your system.

<p>
jupiter tc is a stand-alone test of your config file.
This is helpful, because you don't see the errors at run time.
The first error is reported, with its line number, and then jupiter exits.
Fix your errors one by one until you get a clean run.

<p>
jupiter tts is a stand-alone test of the text-to-speach preprocessor.
Type in words or sentences and it prints what it would send to the synthesizer.
EOF or control c to terminate.
This helps the user understand how jupiter behaves, in conjunction with the config file,
and it helps the developer diagnose and fix bugs.
Use jupiter ltts to do the same thing with literal mode on.
Thus x,y produces x comma y.

<h2 id=syn>Synthesizers</h2>

<p>
This adapter, like Speakup or Orca or any other adapter, requires a speech synthesizer.
There are two flavors.
An external synthesizer plugs into the serial port on your computer
and runs as a peripheral,
apart from your sound card and speakers.
In contrast, a software synthesizer is a program that runs on your computer and uses the in-built sound card.
I prefer an external synth, because it runs independently of my music.
They run through different channels, and I can control them independently.
I turn up the music when I am taking a break, and I turn down the music when I have to think.
But a software synth has distinct advantages too.
It does not require a serial port (some computers don't have these ports any more),
and I don't really want to carry a hardware synth and cables with me when I am on the go.
That kinda defeats the purpose of a laptop.
Also, a software synth can be updated from time to time,
to fix bugs or improve the speech.
So there are pros and cons to these two approaches.

<p>
The hardware synths, or external synths, that are supported are shown by the usage message.
Type jupiter with no arguments to get the usage message.
After a few options, the first argument is the synthesizer.
Here are the supported hardware synthesizers.

<p>
dbe = doubletalk external
<br>
dte = dectalk external
<br>
bns = braille n speak
<br>
ace = accent

<p>
The second argument determines the serial port.
This is 0 through 3, for /dev/ttyS0 through /dev/ttyS3.
On my system I invoke `jupiter dbe 0' for the DoubleTalk synthesizer on /dev/ttyS0.

<p>
A computer without a serial port can still connect to an external synth using a usb to serial converter.
Use u0 for /dev/ttyUSB0, and so on.

<p>
The only software synthesizer currently supported is espeakup,
which, fortunately, supports a variety of languages.
Jupiter connects to espeakup through a pipe, sending text to be spoken,
and receiving index markers in return.
Again jupiter is invoked with two arguments.
The first is esp, for espeakup, and the second is the command to launch espeakup.
On my system it looks like this.

<p>
jupiter esp "|espeakup -V en-us+klatt4 -a"

<p>
Espeakup is the program to run.
The -V option specifies the language and the voice,
in this case English, as pronounced in the United States,
using the male voice klatt4.
Finally the -a option tells espeakup to operate through a pipe,
as required by Jupiter.

<p>
You can test your system by:

<p>
echo "hello world" | espeakup -V en-us -a

<h2 id=run>Running at boot</h2>

<p>
The easiest way to get the system to run Jupiter
at boot time is to include the command to run Jupiter in the /etc/rc.local file.
For example, if you installed Jupiter to /usr/bin/local/jupiter,
and you want to use espeakup, the /etc/rc.local file might contain:
<br>
<pre>
#!/bin/sh
/usr/local/bin/jupiter -d -a esp "|/usr/bin/espeakup -V en-us -a"
</pre>
<p>
Make sure that this file is executable:
<br>
sudo chmod a+x /etc/rc.local
<p>
This should get the system to run Jupiter as root.

<h2 id=modes>Modes</h2>

<p>
Jupiter has several modes that are on or off, enabled or disabled.
Bind these to function or control keys, and you can turn these modes on or off at will.
Most of these modes are global to all consoles.
For example, if autoread is on, then it remains on even if you switch from console 2 to console 8.
But some modes are per-console.
For instance, you may have an application running on console 9 that has to operate in screen mode,
while all the other consoles run happily in linear mode.
The modes are as follows.

<dl>
<dt>Sounds

<p>
<dd>
If it is the middle of the night and your roommate is asleep, you can disable all the chirps and clicks and beeps from the pc speaker.
This includes the clicks that accompany tty output,
and also the short beeps that Jupiter uses to convey status or error conditions.
They can all be turned off in one go.
When sounds are off, words replace most of the beeps.
Toggle modes say "yes" or "no" for on or off,
the mode key says "mode",
a key that calls for a line of text says "input",
mark1 for cut&amp;paste says "mark",
cut says "cut",
the control G bell becomes "error",
and the two quick beeps that indicate a boundary condition are replaced with "boundary".
These words, like all the inbuilt words of Jupiter, can change with the language.

<p><dt>Clicktty

<p>
<dd>
If sounds are on, you can still disable the clicks associated with tty output.
That still leaves the beeps and tones that Jupiter produces for empty buffer, end of buffer, input error, toggle mode, etc.
Without clicktty, output is no longer throttled, and it flies across the screen at lightning speed.

<p><dt>Transparent

<p>
<dd>
In transparent mode, Jupiter steps aside, as though it was not running at all.
Function keys pass right through, and it is not possible to read any text.
Also, the sounds are disabled.
Jupiter watches for one and only one keystroke, the one that turns transparent mode off
and brings Jupiter back to life.
You will hear three ascending tones when transparent mode is enabled,
then three descending tones when transparent mode is turned off and Jupiter returns.
Text accumulates in the tty buffer even in transparent mode,
so you can see what happened while Jupiter was quiescent.

<p>
This mode runs per console.
Put console 1 in transparent mode and switch to console 2, and Jupiter is talking again.
Thus you could leave a console in transparent mode for your sighted friend.

<p><dt>Screen

<p>
<dd>
Jupiter reads tty output by default,
but in screen mode it will read the text from screen memory.
This is useful if a program uses curses to arrange text on the screen in a certain manner,
and you need to read it exactly as it appears on screen.
I try to avoid programs like this,
because (A) I don't like them, and (B) Jupiter is not as efficient in this mode.
The reading cursor does not track the visual cursor as efficiently as one might like,
and some international characters are misrepresented in screen memory.
Still, there are times when a screen program is the only game in town,
and in those situations you just have to play along.

<p>
Due to some hard compiled limits, screen mode will not work at all if the screen has more than 20,000 cells.
Jupiter will simply buzz for larger screens and remain in linear mode.
The largest screen I've run into so far is 48 by 170 = 8,160.

<p><dt>Oneline

<p>
<dd>
If oneline is enabled,Jupiter reads to the end of a line and then stops.
A line is delimited by newline in the tty buffer, or the edge of the screen if screen mode is enabled.
If oneline is disabled then Jupiter reads all the way to the end of the buffer or the end of the screen.
You may want to explicitly set or clear oneline mode in your reading commands.
If F3 reads the previous line, and F4 reads the next line,
they should perhaps set oneline mode to stop at the end of that line.
If F5 reads the rest of the screen or the rest of the buffer, it should clear oneline mode.
But it's up to you of course.

<p><dt>Autoread

<p>
<dd>
If the computer generates a new batch of output, jump to the end of the buffer and start reading the new output.
The word "new" here is subtle, and very important.
The computer may be cranking out 2 or 3 pages of output,
but I stopped reading because I want to review the exact words or letters in the first sentence.
As I am roaming around the buffer, reviewing the output, more output is added to the end of the buffer.
I don't want Jupiter to drag me down to the end of the buffer and start reading again.
I am busy elsewhere.
So autoread only comes into play if the output is new,
not related to the output I am already looking at.
But how, you may ask, does it determine whether the output is new?
As every comic knows, it's all in the timing.
If a burst of output occurs at least 0.4 seconds after the prior output, it is considered new output,
and autoread will take you down to the end of the buffer and start reading.
Conversely, if the output is less than 0.4 seconds after the prior output,
it is considered more of the same,
and Jupiter won't
take you away from what you are doing to read it, even if you are doing nothing at all.
Try it and see.
Cat a small file, and the clicks begin, and reading begins.
Hit the shutup key and reading stops, but the clicks continue, as output continues.
After the file is done, issue another command,
like echo hello world,
and reading begins with the new output.
This was tricky to program, but you know, it works pretty well.

<p>
If your system is under load, or if you are connected to a distant system via ssh, then 0.4 seconds may not be enough.
This parameter is hard coded in Jupiter, but some day I may make it a tunable parameter in the config file.

<p>
Autoread disables oneline mode.
If there is new stuff to read, and you're not busy reading other stuff,
and Jupiter pulls you down and reads the new stuff for you,
then you likely don't want to hear the first line only;
in fact the second line of the status message might be the important part.
So it makes sense to disable oneline mode at this point.
There is no trouble here,
because your next reading command will probably enable or disable oneline mode as part of its functionality.

<p><dt>Interrupt

<p>
<dd>
If interrupt is active, then any key will interrupt reading.
This is a mode you probably don't want.
I often type ahead, entering the next command while Jupiter is reading the prior output.
By default, Jupiter continues to read until a Jupiter-bound key is entered,
that is, a key that causes Jupiter to take some action.
At that point Jupiter will stop reading.
This includes, of course, the shutup key.

<p><dt>Echo

<p>
<dd>
When echo mode is on, Jupiter echos the keys that you type.
These are the primary keys, alphanumeric and punctuation.
Function keys and the like are not echoed, assuming they perform some function, either through Jupiter or through a running application.
Like the clicks, this is a confirmation of the character on screen.
Type an e, and you hear the e when the e comes back to you, perhaps from far away over ssh.

<p>
This is primarily for people who aren't confident in their typing.
I find it distracting, and since echo mode implies interrupt mode,
it prevents any type-ahead, which slows me down even further.

<p><dt>Literal

<p>
<dd>
When literal mode is on, all punctuation marks are read.
Programmers typically run with literal mode enabled, because every comma, every semicolon, might be important.
When literal mode is off, punctuation marks are passed directly to the synthesizer,
as though you are reading a story.
A smart synthesizer will pause for a comma, pause and lower pitch for a period, and pause and raise the pitch for a question mark.
However, even when reading English text, I usually leave literal mode on.
I have become accustom to hearing commas and periods spoken,
and in my brain it almost has the same effect as the corresponding pauses.
Of course it isn't nearly as funny as Victor Borge's
Phonetic Punctuation.

<p><dt>Number Processing

<p>
<dd>
Jupiter preprocesses numbers so they are pronounced the same way regardless of the synthesizer.
123 becomes one twenty three, 123,456 becomes one hundred twenty three thousand four hundred fifty six,
$3.75 becomes three dollars and seventy five cents,
$8.5 million becomes eight point five million dollars,
and so on.
If your synthesizer handles numbers and monitary amounts well, you might not need this feature.

<p><dt>Control Chars

<p>
<dd>
Control characters, other than newline, tab, and bell, are typically culled from the tty buffer.
If this mode is enabled, they are retained.
This is usually used for debugging.

<p><dt>Override Signals

<p>
<dd>
If the serial connection to your external synthesizer is suspect,
you can use this mode to override the cts and rts signals that are typically used for flow control.
In other words, we switch to software flow control using x-on and x-off.
This is used for debugging serial connections, and is rarely needed.

<p><dt>Debug

<p>
<dd>
When debug is enabled,
the file /var/log/acslog is truncated (not removed),
and status messages are written to /var/log/acslog,
until debug mode is turned off.
This helps me debug the acsint system and the Jupiter adapter.
A typical user will never activate this mode.

</dl>

<p>
Function keys, control keys, or alt keys can be configured to set, clear, or toggle any of these modes.
Key bindings will be discussed later.
Some of these modes, like the oneline mode, are changed often,
and you may want a handy, unshifted key to toggle this mode.
Turn it off when you can sit back and read a page of text,
and turn it on when you have to concentrate on technical material, and you only want to hear one line at a time.
Another mode that changes frequently is clicktty.
Sometimes you want to hear all those clicks, and sometimes,
e.g. when there is a lot more output than you expected, you want to shut them off at the touch of a button.
Thus I use F9 to toggle oneline, and F10 to toggle clicktty.
Other modes are changed infrequently, and can be modified by key chords or key sequences.

<h2 id=cfg>Config files</h2>

<p>
At startup, Jupiter reads its key bindings, and loads its replacement dictionary,
from the file /etc/jupiter/start.cfg.
This can be changed using the -c option.
The syntax and semantics of the config file will be described later.

<p>
The config file can also be loaded at runtime,
so that you don't have to restart Jupiter.
After the reload key is pressed,
you can type in the name of a file to load, or preset the key to load a given config file.
If an entered or preset filename does not begin with a slash, it is taken relative to /etc/jupiter.
This is different from the -c option,
where the filename is taken relative to the current directory.
Here is my key chord for the reload function,
an unlikely combination, control alt plus, since I don't exercise this very often.

<p>
@^#+ reload start.cfg

<p>
If you wish, each console can be associated with a separate config file.
Jupiter uses the start config file unless you indicate otherwise.
It is possible to build a specialized config file, to run in console 9 for example, where you might be running an application that requires the function keys or control keys.
You could move the speech functions out of the way, and this customized keyboard layout would take effect every time you switch to console 9.
The association is made through the reload command.
While in console 9, you could activate `reload console9.cfg', for example.
I have never used this feature in 40 years and I don't think I ever will.
My muscle memory strikes keys quickly and automatically, to move about in the buffer and read text,
and it would be quite derailed if the key assignments changed from console to console.
I document the feature here simply because it exists, and it works.
If you don't do anything special, all consoles will use the start config file, and all will be well.

<p>
A config file can include another, like #include in C.
Thus a section like your replacement dictionary
can be maintained in its own file.
You could write your emoji pronunciation section once, and include it in multiple config files,
if you choose to exercise that capability.
Again, these include files are taken relative to /etc/jupiter.
Here is the include syntax.

<p>
&lt;&lt; emojis

<h2 id=rc>The reading cursor and atomic commands</h2>

<p>
The reading cursor is a location in the tty buffer (in linear mode),
or on screen (in screen mode),
that corresponds to the letters or words you are reading or would like to read.
This is independent of the visual cursor that is on the screen, where text is entered or modified.
Thus you can read the text anywhere on the screen,
just as a sighted person might lift his eyes to read the text at the top of the screen,
or lower his eyes to read the status message at the bottom of the screen.
In linear mode the effect is even more pronounced.
You might wonder exactly what happened two hours ago,
when you typed in rm *.
Were you in the right directory?
Did you accidentally delete something important?
Use the search function to find rm * in the tty log,
then read the line before to see what directory you were in,
then read the line after to review the computer's response,
exactly as it took place
some two hours ago (assuming not a lot of output between then and now).
Other screen readers refer to this roaming about as "screen review mode".
Fair enough, but a bit misleading if you are in linear mode,
for then you are reading text out of the tty buffer and not off the screen.

<p>
Various atomic commands move the reading cursor about in the tty buffer or on screen.
These are not typically issued on their own.
Instead, they are often put together in a sequence, then bound to a key.
For instance, F2 might move the reading cursor to the start of a line and then read the character
at the beginning of that line.
This is two atomic commands put together to make one composite command, which is then bound to F2.
In this manner, relatively complicated commands can be built.
You could construct a command that reads the top line of the screen, then the third line,
then leaves the reading cursor at the end of the second line.
That is a bit contrived, but it illustrates what can be done.

<p>
Here is a list of the atomic commands that relate to the reading cursor.
Each command has a brief name, about 6 characters, that you will use in the config file,
followed by a description of what that command does.

<dl>
<dt>cursor:
<dd>
Move the reading cursor to the visual cursor on screen.
This is where the action is.
A composite command might go down to the bottom of the screen, read the status message,
then issue this command to go back to the visual cursor.
This command has no effect in linear mode.

<p><dt>clbuf:
<dd>
Clear the buffer.
Now the buffer is empty.
This generates an error (beep) in screen mode.

<p><dt>sbuf:
<dd>
Place the cursor at the start of the buffer, or the upper left of the screen.
If the buffer is empty you will hear a couple of quick high beeps indicating a boundary condition.
The same sound occurs if you pull the cursor past the start of the buffer, or push it past the end of the buffer.

<p><dt>ebuf:
<dd>
Place the cursor at the end of the buffer, or the lower right of the screen.

<p><dt>sline:
<dd>
Place the cursor at the start of the current line.
In linear mode, lines are delimited by the newline character control J.
Unless control char mode is enabled,
Jupiter turns crlf into lf, so you don't have to worry about extra return characters (control M) cluttering up your tty buffer.

<p><dt>eline:
<dd>
Place the cursor at the end of the current line.
The cursor sits on the newline character that terminates the line.
In screen mode the cursor sits on a mythical newline character that Jupiter inserts for you.
Thus screen mode and linear mode have the same look&amp;feel.

<p><dt>sword:
<dd>
Place the cursor at the start of the current word.
A word is a sequence of alphanumerics, as per the iso8859-1 page,
and at most one apostrophe,
or one unicode that is equivalent to an apostrophe, such as 0x201d.
Thus ni&ntilde;o looks like one word, no matter your language setting.
After all, an English speaker might encounter this while reading an article about climate change,
thus it should be one word.
The same for caf√©, and so on.

<p>
Hello3world is one word in any language.
Many variables in computer programming, or in math, are a mix of letters and numbers,
and it is convenient to treat these as compound words.

<p><dt>eword:
<dd>
Place the cursor at the end of the current word.

<p><dt>wordlen:
<dd>
Read the length of the current word.

<p><dt>lspc:
<dd>
Move the cursor to the left through spaces,
stopping at the last space.
If there are no spaces to the left of the cursor then it remains in position.
This command should perhaps skip past higher unicodes that are equivalent to a space, such as 0xa0.
That is still under consideration.
As you might imagine, this is rarely used on its own.
Rather, it is used in sequence to skip past whitespace and read the next word.

<p><dt>rspc:
<dd>
Move the cursor to the right through spaces,
stopping at the last space.
If there are no spaces to the right of the cursor then it remains in position.

<p><dt>back:
<dd>
Move the cursor back one character.

<p><dt>for:
<dd>
Move the cursor forward one character.

<p><dt>prow:
<dd>
Move the cursor up one row.
Sound an error if there is no previous row, or if the previous row is too short
to remain in your current column.
Obviously this latter condition cannot occur in screen mode, since all rows are the same length.

<p><dt>nrow:
<dd>
Move the cursor down one row.

<p><dt>lcline:
<dd>
Put the cursor at the start of the last complete line.
This is meant to read the last line of output, just before the prompt.
In screen mode the cursor is at the start of the second to last line,
assuming the last line is a prompt.

<p><dt>delim:
<dd>
Set one or more delimiters, to stop reading if in oneline mode.
Reading always stops at the end of a line, but it can stop at any ascii punctuation mark.
| is a common delimiter, as it separates fields in a table.
Up to 7 different delimiters are allowed.
|` stops reading at either pipe or backtick.
These delimiters are set per console.

<p><dt>colnum:
<dd>
Read the current column number.
The first character in a line is in column 1.
Remember that lines can be very long in linear mode.
A series of dots, indicating progress in a file transfer,
could create a line that is hundreds or thousands of characters long.

<p><dt>char:
<dd>
Read the current character.
A letter or digit is simply passed to the speech synthesizer.
Control G sounds the bell if sounds are enabled,
or says the word bell if sounds are disabled.
Control J issues a quick swooping sound that is specific to newline, if sounds are enabled,
or says the word newline if sounds are disabled.
Other control characters are typically culled from the buffer.
If control K is present however, it is read as "control K".
A punctuation mark is read using a default word or phrase,
unless you override its pronunciation in your config file.
The symbol ! might be read as exclamation point,
but you may prefer the shorter word bang.
Finally a higher unicode is spoken as directed by your config file,
or it is simply said as the word code followed by the unicode in hex.
If you do math, for instance, you may want to set the pronunciations of the math symbols in your config file.

<p>
Capital X is read as "cap X", rather than simply x.
I use to have a separate command for this, capchar, and that is still supported for legacy reasons,
but now char is the same as capchar, just as the word command always indicates the capitalization of the word.

<p><dt>asword:
<dd>
This is the same as char,
but a letter is read as a word, using the nato alphabet.
This is used to distinguish between similar sounding letters such as m and n.
The former is read as Mike, and the latter as November.

<p>
If the character is nonascii, its unicode value is read in hex format.
If you have set x1f600 to grin in your config file, it is read as grin by characters, by words, or in continuous reading,
but asword tells you that it is code 1f600.

<p><dt>casw:
<dd>
A combination of char plus asword.
n november, for example.

<p><dt>word:
<dd>
Read the current word.
The entire word is read, even if the cursor is in the middle of the word.
The cursor is left at the end of the word.
To aid in pronuncibility, spaces are inserted at letter-digit or case boundaries.
Thus RedGreen3Blue is pronounced "red green 3 blue".
This is usually what you want.

<p>
If the word is capitalized, cap is prepended, as in cap Saturday.
This is consistent with the char command.
allcap indicates the entire word is in upper case, and mixcap indicates a mix of upper and lower case.
This can save time;
you thence don't need to look letter by letter.

<p><dt>read:
<dd>
Start continuous reading.
Jupiter will begin reading, and will not stop until you interrupt it,
or it reaches the end of a line and oneline mode is enabled.
The cursor tracks the words you are hearing.
Thus you can stop it at any time, using any of these commands,
and the cursor will be on the word you last heard.
If something doesn't sound right, stop reading and review the individual words and letters.
You can then resume reading at this point if you like.

<p><dt>shutup:
<dd>
Stop reading, but take no other action.
This leaves the cursor on or near the word you last heard.

<p><dt>speak:
<dd>
speak the next string at this point in the command sequence.
This lets you specify a word or phrase, instead of the default that Jupiter provides.
If the previous command sets or clears a mode, you can specify two different phrases separated by pipe.
For example, the following sequence causes control f5 to toggle screen mode, and then say screen on or screen off.

<p>
^f5 toggle s speak "screen on|screen off"

<p>
If speak is the only command, ^f5 speak, then Jupiter takes input from the keyboard and sends it directly to the synthesizer.
This can be used as a test, to see how things are spoken without any preprocessing.
The same can be accomplished by sending text into /etc/jupiter/fifo, described below, but this can be more convenient.

<p><dt>label:
<dd>
This command waits for you to type a letter, then sets a label, using that letter,
at the current location in the buffer.
If you are at the start of the buffer you might issue this command, then type the letter t, to mark this as the top of the buffer.
That's rather silly, since there is already a start of buffer command, but I present it as an example.
Then jump t will take you back to this location.
This is primarily used in linear mode, where you may want to mark several locations in your tty buffer.
It can be used in screen mode, but the labels are not guaranteed to stick if more output is generated and the screen scrolls.
It only makes sense if the screen is static.

<p>
Note, all labels go away if you switch between line mode and screen mode.
They have no validity in this new context.
Perhaps they should return if you switch back, but this is not implemented.

<p><dt>jump:
<dd>
Enter a letter and jump to the location in your buffer that was set using that letter.

<p><dt>mark1:
<dd>
Mark this as the start of some text that you want to copy.

<p><dt>mark2:
<dd>
Mark this as the end of some text that you want to copy.
You must then enter a follow-on letter,
whence the block of text between the start and end marks is associated
with the left-alt of that letter.
You should probably leave most of your alt-letters unbound, so they can be used for copy&amp;paste.
The text is not associated with the right-alt (alt graphics) of that letter.
AltGR is sometimes used by international keyboards to generate accented letters or other symbols,
and we do not want to interfere with that.

<p>
As an example, put your cursor on the h in hello world and issue mark start.
Then move the cursor to the d in world and issue mark end, followed by h.
Now alt-h will generate "hello world", as though you had typed it in.
The same thing happens if you mark d as the start of your text and h as the end.
After you get use to using copy&amp;paste, you will become absolutely dependent on it.
I'm getting older, and can hardly remember a 7 digit phone number any more,
so I use copy&amp;paste to copy it from one file to another.

<p><dt>searchd:
<dd>
Search down the buffer for a string of text.
Enter the string at the keyboard, using ascii only.
The search is case insensitive, and letters will match their accented counterparts.
There is no need to enter o umlaut (In German), just type o and it will match o umlaut.
If this is the last command in the sequence, and a match is found,
Jupiter will read the current line in oneline mode, or simply say ok otherwise.
Of course you can follow this up with other commands,
e.g. read the line just before the line that contains the phrase "oreo cooky".

<p>
If no string is entered, the last string is used again.
These remembered search strings are per console.

<p><dt>searchu:
<dd>
Search up the buffer for a string of text.
The behavior is as above, except the cursor moves backwards rather than forwards.

</dl>

<p>
While we're in the neighborhood, let's describe some other atomic commands.
As you recall, Jupiter runs in several different modes.
These modes can be set, cleared, and toggled using the
stmode, clmode, and toggle commands.
A follow-on letter determines the mode.
Thus stmode s sets screen mode, and clmode a clears autoread mode.
The letters and modes are as follows.

<p>
s screen mode versus linear mode
<br>
a autoread
<br>
n sounds (n is for noises)
<br>
t clicktty, clicks accompany program output
<br>
1 oneline mode
<br>
i interrupt speech with any key
<br>
e echo keys as typed
<br>
l literal reading of all punctuation marks
<br>
m preprocess numbers for a standard pronunciation
<br>
c control chars in buffer
<br>
o override rs232 signals, software flow control
<br>
d debug messages in /var/log/acslog

<p>
Most reading commands will start by setting or clearing oneline mode.
To read the next line, and only the next line, do this.

<p>
stmode 1 eline for read

<p>
To read from your current location to the end of the buffer, do this.

<p>
clmode 1 read

<p>
Several atomic commands control the speech synthesizer.
Some of these may not be implemented, depending on your synthesizer.

<p>
The volume, speed, pitch, pitch range (intonation), and voice can be set,
using the volume, speed, pitch, range, and voice commands.
Each command takes a follow-on digit from 0 to 9.
0 is the slowest speed and 9 is the fastest, and similarly for volume, pitch, and range.
The voice command selects one of several voices, and then says "hello there",
so you can hear how the voice sounds.
However, this is only implemented for a couple of external synthesizers.
Yes, espeakup has several voices to choose from, but you cannot change them on the fly.
It is a -V option that is part of the espeakup command line.

<p>
Other commands increase or decrease these parameters as follows.

<p>
incvol increase volume
<br>
decvol decrease volume
<br>
incspd increase speed
<br>
decspd decrease speed
<br>
incpch increase pitch
<br>
decpch decrease pitch
<br>
incrng increase pitch range
<br>
decrng decrease pitch range

<p>
It's nice to have some nearby keys to increase and decrease volume,
commensurate with the background noise of your surroundings.

<p>
Here are a few more system commands.
Like the synthesizer commands, these are run on their own,
and not combined into larger commands.

<dl>
<dt>bypass:
<dd>
What happens if F2 reads the current line, and yet you have to pass F2 to your running program?
The bypass command takes the next key and passes it through, as though it had no meaning.
This is rarely needed in linear mode,
except to pass control D through for EOF, and control C for interrupt.

<p><dt>bind:
<dd>
Read a text string from the keyboard and pass it to Jupiter as though it had come from the config file.
Thus you can change key bindings or pronunciations on the fly.
This is generally used for testing.
You should really keep your keyboard layouts and pronunciations in config files.

<p><dt>reexec:
<dd>
Restart the adapter.
This is for developers; after you have made a change to the software you can restart the program with one button.
The same arguments are passed to the program.

<p><dt>reload:
<dd>
Reload a config file.
The name of the file is entered at the keyboard,
and is taken relative to /etc/jupiter, unless it begins with a slash.
Issue this command if you have made a change to your config file,
or you want to use a different configuration
file.
If the file cannot be found, or is unreadable,
Jupiter sounds the error bell and retains the preexisting configuration.

<p><dt>dump:
<dd>
Dump the current buffer, in utf8, to /tmp/bufn, where n is the number of your current console.
This is a snapshot of the tty log or screen memory.

<p><dt>suspend:
<dd>
Suspend the adapter.
Activate transparent mode, as described in an earlier section.

<p><dt>notes:
<dd>
Play a sequence of notes on the pc speaker using parameters drawn from a file.
The name of the file is entered at the keyboard,
and is taken relative to /etc/jupiter, unless it begins with a slash.
If the first character in the file is n, then jupiter plays a series of notes.
The file contains pairs of numbers separated by commas.
Each pair is a frequency in hurtz and a duration in jiffies.
Some whitespace is permitted.
At present the max number of notes, including rests, is 50.
This feature is for playing helpful sounds and alerts, not for playing concertos.

<p>
If the first character in the file is s, then jupiter plays a scale, of sorts.
The file contains 4 numbers separated by commas.
The first is a start frequency and the second is an end frequency.
The third is a geometric step, as measured in percent.
Thus 6 takes steps of 6%,
which produces a traditional chromatic scale.
A negative step gives a descending scale.
The fourth number is the duration of each note in hundredths of a second.

<p>
Examples are in the sounds directory.

</dl>

<h2 id=vc>The visual cursor and autoread</h2>

<p>
This section has no meaning in linear mode; it only applies to screen mode.

<p>
The visual cursor is the location on the screen where new text is entered, or preexisting text is modified, or settings are changed, or other work is done.
The sighted user has his eyes on the visual cursor most of the time,
and in the same way, the blind user is reading the text at or near the visual cursor, most of the time.
To support this, the reading cursor jumps to the visual cursor whenever the cursor moves, or when any new output is generated.
In other words, the reading cursor is the visual cursor, unless you are specifically roaming about the screen.

<p>
Autoread will read any new output in the order it is generated.
In fact autoread still acts like you are in linear mode.
If a program updates the status message at the bottom, then the file line at the top,
you will hear these two "sentences" in that order; then the reading cursor will return to the visual cursor on screen,
wherever that is.
If you interrupt reading with any key, the reading cursor is on the visual cursor, rather than the words you last heard.
This is different from linear mode.
However, if you initiate reading yourself, in screen review mode,
then the reading cursor once again tracks the words you are hearing.
You can stop and focus in on specific words or letters on the screen.
Remember however that there are occasional non-ascii errors that I have no way to correct.
Autoread is always right, because it reads out of the linear buffer,
but screen review mode will sometimes lose the accent off of a vowel,
or even replace a high unicode with another.
On my system the German s-zet is replaced with the Greek beta, for example.
That's just one more reason to run command line programs whenever possible.

<p>
There is another form of autoread that is unique to screen mode.
If the cursor moves one character left or right,
usually because you have hit the left or right arrow key,
then Jupiter reads the character under the cursor in its new location.
If the cursor jumps several spaces left or right,
Jupiter reads the word under the cursor in its new location.
If the cursor moves up or down a row,
Jupiter reads the line of text on the new row.
This gives you feedback as you move the visual cursor about on screen.
It is one more way that Jupiter tracks the visual cursor for you.

<p>
This is a cursor-induced form of screen review,
so once again the reading cursor tracks the words you are hearing.
If you don't interrupt speech, then the reading cursor jumps back to the visual cursor
in its new location.

<p>
On its own, this system is not as responsive as you would like.
You cannot hit down arrow rapidly in succession to move through several lines on the screen.
Yes, the visual cursor moves down, but Jupiter is still reading the second line of text.
You have not specifically interrupted speech, and autoread does not interrupt autoread.
So you are still hearing the line of text that is several lines above the new location of the visual cursor.
The secret is the T function, named after /usr/bin/tee.
This replicates the arrow key and sends it to the running program
(such as a text editor) and back to Jupiter for processing.
Jupiter will simply interrupt speech; then when the cursor moves,
autoread will read the next line.
In this way you can move up or down through the lines on the screen quickly and efficiently.
The arrow bindings in your config file might look like this.

<p>
# arrows move cursors, so it's a good idea for them to interrupt speech.
<br>
up T shutup
<br>
down T shutup
<br>
left T shutup
<br>
right T shutup

<p>
Don't try to perform the autoread function yourself.
Don't ask Jupiter to read the next character like this.

<p>
right T char

<p>
This works if the application receives the arrow key first, before Jupiter,
but there is a race condition here that cannot be predicted or resolved.
Jupiter may receive the key first,
whence it stops reading and speaks the current character.
Then the program receives the arrow key and moves right.
You will hear the character that the cursor was on before,
rather than the character that the cursor is on now.
The T function should only be used with the shutup command;
then Jupiter can perform autoread as it was programmed to do.

<h2 id=cfs>Config file syntax</h2>

<p>
Each line in a config file is one of the following.

<ul>
<li>
A line consisting of white space, or a line whose first nonblank character is a pound sign.
These are ignored.

<p><li>
key command1 command2 command3 &#8230;
This is a key binding.
The commands are the atomic commands described above.
These move the reading cursor about, read letters or words or lines,
set and clear modes, control the synthesizer, or modify the system in some way.
Letters or strings can be included inline for those commands that require follow-on input.
Here f6 toggles autoread, and f7 searches for the word banana in the buffer.

<p>
f6 toggle a
<br>
f7 searchu banana

<p>
Use quotes for a follow-on string, like this.

<p>
f7 searchu "my favorite martian"

<p>
The key is f1 through f12 for the function keys, #0 through #9 for the digits on the keypad,
#. #+ #- #* #/ #e (enter) for the remaining numpad keys,
up down left right for the arrows,
and home, end, pageup, pagedown, insert, delete, leftmeta, rightmeta, scroll, pause, and sysrq.
Don't worry, Jupiter knows that a line like this is not a comment.
Instead, it causes numpad 7 to read the previous line,
and then leave the reading cursor at the start of that line.

<p>
#7 stmode 1 sline back sline read sline

<p>
If a key does not have a name in Jupiter's lexicon, you can specify the keycode directly, as below.
Use the showkey command to find the key code.

<p>
k110 colnum

<p>
Keys can be modified by shift, control, or alt, in all combinations.
The designators are +, ^, and @ respectively.
Thus @home is alt home key, and +^f3 is shift control f3.
You can specify the left alt key with l@ or the right alt key with r@.
Thus r@u is right alt u, but not left alt u.
Using @ by itself implies either alt key,
just as + implies either shift key.

<p>
Map plain function keys or plain numpad keys to the reading functions that you perform often.
Or - you may wish to assign some of these to control letters, so you don't have to leave the home row,
but bear in mind, certain applications like nano and vi use control characters to perform their functions,
so you would have to bypass the speech function in order to pass the control character to the application.
Even 99% linear users like myself must remember that standard tty uses ^c for interrupt and ^d for EOF.

<p>
Rarely used commands, like restarting the adapter, can safely be assigned to awkward key chords like control alt #+.
It's all a matter of taste.

<p>
For one last example, control u gives the level of indent, which is important if you are a programmer,
especially a python programmer.

<p>
^u sline back rspc for colnum

<p><li>
Make a key act like a modifier.
It is sometimes convenient to let the large 0 key on the numpad modify the other keys.
In other words, hold down 0, and the other keys take on different functions,
as though you were holding down shift or alt.
Speakup users will be familiar with this behavior.
The following line causes numpad 0 to simulate the right alt key.

<p>
#0 r@

<p>
If @#5 reads the current line,
you can accomplish the same thing by holding down #0 and hitting #5.

<p>
A key can also simulate a modifier combination, such as #0 +r@, for shift and right alt together.

<p><li>
Bind a key to a macro.
<p>
If you follow a key with &lt;, the rest of the line is text to send to standard input.
Include \n to send a newline.
Include \\ to send a literal backslash.
\ followed by anything else is a literal backslash, as in a\b.

<p>
^f9&lt;Kind regards\n\nFred Flintstone\n

<p>
If you follow a key with |, the rest of the line is a system command to execute.
<p>
scroll|amixer -q set Master 3%+
<p>
See music+speech.txt for more of these system commands.

<p><li>
Set the pronunciation of a punctuation mark.
The syntax is the punctuation mark, whitespace, and the word or words to say.

<p>
( left parenthesis
<br>
) right parenthesis

<p>
The words can be international, in utf8.
However the punctuation mark must be in ascii.
To set the pronunciation of a high unicode,
specify the unicode in hex or in decimal.
Set alpha beta gamma like this.

<p>
x3b1	alpha
<br>
x3b2	beta
<br>
x3b3	gamma

<p>
Or like this.

<p>
u945	alpha
<br>
u946	beta
<br>
u947	gamma

<p>
You will probably amass a large collection of emojis, just to read social media and casual emails.
entries like x1f61c tongue out and winking, or x1f422 turtle.

<p><li>
Replace one word with another as text is being read.
The word must consist of letters in your language, in utf8.
It can be replaced with any string, again in utf8.

<p>
syzygy sizijee
<br>
sleight slite
<br>
czech check

<p><li>
Include another config file.
The file is taken relative to /etc/jupiter, unless it begins with a slash.

<p>
&lt;&lt; high-unicodes
<br>
&lt;&lt; dictionary

<p><li>
Execute some commands right now, indicated by two leading colons.
This is used to put Jupiter in an initial state.
Set the volume and speed of the synthesizer, for example.

<p>
:: volume 5 speed 8 stmode l

</ul>

<h2 id=fifo>Jupiter fifo</h2>

<p>
In unix or linux, a fifo is a virtual file that carries data from one running program to another.
A particular fifo is used to pass text or instructions from other programs into Jupiter.
Create the fifo like this.

<p>
sudo mkfifo -m 660 /etc/jupiter/fifo

<p>
Change the group of the fifo to a group that only includes users who you trust to use the fifo.
For example, if the tty group is that group:
<br>
sudo chown root:tty /etc/jupiter/fifo

<p>
Any text sent to this fifo is passed directly to the synthesizer without processing.
Verify the fifo like this.

<p>
echo hello world &gt; /etc/jupiter/fifo

<p>
If you cat a large file into the fifo, you may have to listen to the entire file,
with no way to interrupt it.
That's not a great idea.
You will typically echo small text fragments or synthesizer commands into this channel.
It is used for debugging, or to verify the behavior of the synthesizer.
It is also used for alerts.
A program can send status messages, or a completion message, into the fifo,
and you will hear it, even if the program is in the background or on another console.

<p>
If a line begins with two colons,
then it is interpreted by Jupiter as speech commands.
An external program could cause Jupiter to jump to the start of the buffer and start reading,
though I don't know why you would do that.

<p>
echo ':: clmode 1 sbuf read' &gt; /etc/jupiter/fifo

<h2 id=sum>Summary</h2>

<p>
Jupiter is written in three layers.
The modules (1) provide audio feedback as output is generated,
and pass keystrokes and tty output back to user space.
This layer is well documented in ttyclicks.txt and acsint.txt,
but is a bit like a raw block device - impractical to use.
The bridge layer (2) places, metaphorically, a file system on top of the modules.
It is documented in acsbridge.h.
Adapters such as Jupiter will want to use the bridge layer, rather than the device driver itself.
Finally, Jupiter (3) is an example of such an adapter.

<p>
Note that Jupiter is extremely configurable;
you can make it be just about anything you want it to be.
Writing the config file, or files, is the key.
It takes some practice, some trial and error.
The sample config file may be of some help.
As always, you can
<a href=mailto:eklhad@gmail.com>contact me</a>
with any questions.

<p>
<a href=#top>Back to top</a>

</body>
