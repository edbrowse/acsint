This file describes the creation of a talking raspberry pi, or perhaps any debian system,
or perhaps a linux system in general.
I will assume you have another talking computer at your hand.
You can use one to configure the other.
If you don't, then you will need a bit more help from your sighted friend, (I'll call him Bob),
but it is still manageable.

Attach a pi-compatible SD card to your computer,
probably via a usb card reader.
It's ok if the SD card has no filesystem on it; it could be fresh from the factory.
Even if it does have a filesystem on it, you're going to overwrite it.
No need to mount it or look inside.
Download a Raspberry pi image, whatever version you prefer,
probably the latest version, and copy it onto the SD card.
This is an image copy, /bin/dd under unix.
Probably some kind of drag and drop in Windows; I don't know anything about Windows.
At this point you could put it into a pi and start it up,
but there might be other useful things you can do first.
See the paths A B and C below.

If you don't have a talking computer,
then Bob will copy the boot image onto the SD card for you.
It's not difficult, and it doesn't take long.
I have a talking computer and still I have my friend do it for me,
because he can do it faster than me and that's all there is to it.

Now there are three paths.

A) Put it in a pi and bring up Raspbian for the first time.
It doesn't always have to be your pi, sometimes it can be a different pi,
perhaps Bob's pi at Bob's house.
As a general disclaimer, the setup pi should be the same as the destination pi,
but I have used a different pi on occasion, without trouble,
assuming the pis are the same model, e.g. both pi-4.
In any case, Bob will start the process for you.
Raspbian comes up on screen, no adapters, no speech,
and asks some very simple questions:
country, time zone, name of the computer, etc.
Bob will fill all these things in for you.

B) Before Bob puts this SD card into a pi, ask him to mount it as a drive,
so he can put some important files under /boot.
These will cause the first boot to set up some good things for you,
so Bob doesn't have to manage them with the GUI.

C) If you have a talking computer, and you downloaded the image and put it
on the card yourself, then perhaps you can mount it and put some files
on the boot partition.
That saves a few steps for Bob,
just as it did in path B.

B and C assume you can mount an ext4 partition.
Windows can't do that.
There are some third party tools that attempt to read and write ext4 safely,
but honestly I think that's a bit dicey.
There are some linux emulators under Windows and these work pretty well,
but that's a lot of work just to go down path C.
If neither you nor Bob has a linux computer, I recommend path A.

When Bob brings up Raspbian for the first time,
it will ask him to make a user account; he should do this.
You can't work 100% as root.
One slip of the finger and there goes /bin.  Oops!
Tell Bob your login and password, probably the one you use
on all your computers, maybe the one you've been using since 1978,
(eklhad in my case, my last name backwards).
If you don't trust Bob, and that would be a sorry state indeed,
then give him a temp password; you can change it later.

But there is another way, relative to paths B and C.
Create the file /boot/userconf.txt containing a line of the format
<username>:<hashed password>
This creates a user account with that username and password on first boot.
You can try something like
echo "your_login:$(openssl passwd -6 -stdin)" > userconf.txt
and type your password, and put that file on the /boot partition of the micro
SD card before its first boot.
Now Bob will be able to skip that step.
Once your user account is created, you can safely remove /boot/userconf.txt,
although the pi has probably done this for you.

Whether created interactively by Bob, or by /boot/userconf.txt,
this user account has administrative privileges.
That means you will be able to use sudo, and perform root commands. You will need this;
if you can never be superuser, then the computer is practically useless.

At first boot, the pi may ask Bob for the root password.
Some linux distributions do this, some don't.
If prompted, ask Bob to type it in for you.
If not, you can do without it for a while, thanks to sudo,
but you will need it eventually.
If there is no root password, debian will not go into rescue mode.
Suppose there is a kernel panic - rare, but it happens.
Or suppose there is a power failure.
The unit comes up with a corrupt filesystem and runs fsck.
Suppose there is a problem that it cannot solve, and it requires human intervention.
This is when it switches to rescue mode - but if there is no root password,
then that option is off the table.
Your computer is inaccessible, permanently!
Bob has no advantage here, his eyes do not help you get in.

We can assume your pi won't crash for a while,
but at some point you need to run
sudo passwd
It will ask for the root password.
If it instead asks for your password, then sudo didn't take effect,
and you aren't really root.
I don't know why that would happen.
So make sure it asks for root password,
type it in twice, and then you're good to go.
Type su as a test; put in the root password; make sure you are root.
Then exit to get back to your user account.
You can still use sudo, but if you have a lot of
root commands to issue, then a superuser session is more convenient.

Speaking of rescue mode, there is an interesting parameter in another
important file under /boot.
Have a look at /boot/cmdline.txt, or /boot/firmware/cmdline.txt.
(You can check this even before first boot.)
This will become important later, when we setup wifi.
This contains options passed to the kernel at boot time.
There are typically more options as linux advances, but at minimum you should see:

console=serial0,115200 console=tty1 root=PARTUUID=6c1463a0-02 rootfstype=ext4 fsck.repair=yes rootwait

This is all on one line.
There may or may not be a newline character at the end.
If you edit it, and inadvertently
put a newline character at the end, that's ok.
Let's look at a couple of these parameters.

root=PARTUUID=6c1463a0-02

Some devices have unique numbers on them, the way each car has a VIN.
Ethernet chips for example, or wifi chips, have a 48-bit mac address.
This is used by the dhcp server to hand out the same ip address to that device
consistently whenever it requests a connection.
They are also used by routers in certain intranet configurations.
Port forwarding for example.
Disks and other storage devices also have a unique number.
It is called a uuid.
This was not always the case.
In the 1990's, /etc/fstab looked quite different, simpler in fact, than it looks today.
It might direct unix to mount / on /dev/sda1
That was fine, but what if the system administrator
moved disks around inside the computer?
Perhaps he wanted that disk to be in slot three, thus /dev/sdc1.
Do we have to update half a dozen files under /etc?
We use to.
But now we refer to the uuid of the disk, and that specifies it directly.
In my fstab, and probably yours, / is mounted on a disk by uuid, partition 1,
and /boot is mounted on a disk of the same uuid, partition 2.
Obviously your uuid will not be the same as mine.

We see why Bob can set up the SD card on his pi, then hand you the card
to place in your own pi.
The uuid is part of the card, and does not change as he hands it to you.

fsck.repair=yes

This boot parameter is mightily important.
Rewind to the 1990's, when this parameter didn't exist.
We've already talked about a kernel panic or a power failure.
The computer comes back up with a corrupt root filesystem.
In those days it always went into rescue mode.
You had to run fsck manually.
Since it switched over to rescue mode, none of the services are running.
Speech is not running. The computer is silent.
The screen is asking you to log in as root and run fsck, but you don't know that.
That is why, among other reasons, jupiter was originally embedded in the linux kernel.
All that software in the kernel, using the kernel functions (which are quite different from libc.a).
The slightest bug brought down the entire operating system.
No debug log, no print statements, no core dump for gdb, just crash!
Figure out what went wrong out of thin air, make a change, rebuild the kernel,
reinstall the kernel, reboot, and try again.
I can't describe how difficult that was!
And yet, speakup went down the same path.
That two people on earth tried to do this is amazing -
like saying two people with no connection to each other both climbed Mount everest on hands and knees.
Well - that is in the past, and most of jupiter, and most of speakup,
now live in user space, with supporting modules to connect to the kernel.
this is a perfect example of convergent evolution.
This is feasible only because todays kernels do not
flop over into rescue mode just because the root filesystem is corrupt.
The fsck.repair=yes parameter tells the kernel to run fsck on its own,
without human intervention,
fix the disk errors if possible, and come up running.
The services launch, the computer speaks, and you don't even know anything was amiss.

This isn't an iron-clad guarantee though.
Some errors cannot be fixed automatically, and then linux has to go into rescue mode.
At that point you probably don't have speech,
but Bob can attach a monitor and perhaps the two of you, working together,
can get the computer back on its feet.
I have given some thought to adding speech to rescue mode,
perhaps connecting the rescue target to the rc.local target,
in the case of jupiter, or to espeakup.service in the case of speakup.
This is difficult to test, and I'm a bit over my head here.
Perhaps you can help me with this one.

cfg80211.ieee80211_regdom=US

This parameter may or may not be in cmdline.txt.
If it is missing, you can add it at the end.
If it is there, but the country code is wrong, you can change it.
Even before first boot.

When I set up wifi on my new pi, it was working, all was well,
and yet the country code was AD, for Andora.
Obviously I don't live in Andora - and yet it worked. I was rather surprised.
I believe it picked AD because it was first on the list in
/usr/share/zoneinfo/iso3166.tab
I changed it from Ad to US and was happy to see that wifi still worked.
But it's a good idea to have your wifi country code correct from the start.
So this is a change you, or Bob, might want to make in /boot/cmdline.txt,
either before you put the card in the pi, or after the fact.

The iw command displays and sets the country code, and is i'm sure the approved method.

iw reg get
iw reg set US

That said, iw reg set didn't work for me.
I had to edit /boot/firmware/cmdline.txt.

The next thing Bob needs to do for you is enable ssh.
This will allow you to connect your already-talking computer to the new pi,
whence you can take over, and Bob can go to lunch.
From the terminal, it is
systemctl enable ssh.service
and if you want it right now rather than upon the next reboot,
systemctl start ssh.service
But of course you aren't at a terminal.
Bob is looking at a graphical interface.
It's easy to find services, then ssh, then turn it on.
Be sure to say yes to both passwords and keys.
You aren't going to ssh in via private key the first time;
you will have to use your login and password.

Once again there is a way to do this on path B or C.
Put an empty file called ssh.txt
on the /boot partition of the micro SD card, to enable sshd on first boot.
You can verify that the service is active through the GUI,
or systemctl | fgrep ssh
It is safe to remove /boot/ssh.txt at this point,
although your pi has probably done it for you.

The easiest way to connect the new pi to your existing talking machine is over ethernet.
Put them both on the same hub or the same router.
(You can connect the two machines directly but that requires a crossover cable,
which most people don't have in their house.)
Or - you can set up wifi on the pi.
Unfortunately the wifi mechanisms vary widely from buster, to bullseye, to bookworm,
and none of them are particularly intuitive.
In buster, everything was in a wpa file under /etc, and that was easy peasy.
Put all your networks there, uncomment the one you want to connect to, and reboot.
All text based.
No GUI, not even a screen. Sweet!
But that method went out the window with bookworm.

Well, Bob can set up wifi from the GUI.
If he hasn't done that, and you are on by ethernet, and you want wifi instead,
there are several methods, again depending on the version of Raspbian.
cat /etc/os-release for  your Raspbian version.

In recent versions of raspbian, nmcli will come to your rescue.
(Remember that cli means command line interface.)
iw is a lower level command, and sometimes that works, but nmcli is more powerful.
I will refer to both when it makes sense to do so.

Using either tool, you will need to know the ssid of your wifi connection.
That's fine if you're home and you know your own networks, but not if you're travelling.
Thus the first step is obtaining a list of ssids.
iw scan will do this for you, but it generates a deluge of incomprehensible output.
You need to filter it, like this.

iw dev wlan0 scan | grep '[^A-Z]SSID: *[^ ]'

Even this will duplicate some of the ssids, but at least it fits on one screen.
nmcli also produces a scan, without the need for a filter.
Again, some of the ssids are duplicated.

nmcli -g ssid,security device wifi

Note, these iw and nmcli commands will not work properly unless run as root.
If the iw scan, (the lower level command), yields error -100, then the wireless device is not up.
Check with ifconfig.
If wlan0 is missing, or lacks the "up running" attributes seen on the other interfaces, try this.

ifconfig wlan0 up

If this yields the error "Operation not permitted due to RF-kill",
then run rfkill, and note that wlan is soft blocked.
Unblock with this command, then run rfkill again to verify.

rfkill unblock wifi
rfkill
ifconfig wlan0 up
ifconfig
iwconfig

These commands should succeed, and wlan0 should be present and up and running.
The iw scan should work now, but the nmcli scan might still come up empty.
If that is the case, it is possible that Bob didn't enable wifi in one of the startup GUI screens.
That could be the cause of all the trouble.
Check by running `nmcli radio wifi'.
This will report enabled or disabled;
if it says disabled, then you better turn it on and perhaps reboot.

nmcli radio wifi on
nmcli radio wifi
reboot

Now, with a little bit of bloomin luck, rfkill shows unblocked,
and iwconfig shows the device, and iw scan works, and nmcli scan works,
and wpa_supplicant.service is running.
Let's take the next step and connect to your home wifi.

In the following, "name home", (optional), gives a nickname to the wifi connection,
which I assume is the one in your home.
You can give short names to other wifi networks as well,
at your friend's house, your daughter's house,
your local McDonalds, etc.

nmcli device wifi connect my_ssid password my_Password name home

It is best to set a nickname on first connect,
then you can refer to this nickname thereafter.

nmcli connection up home
nmcli connection down home
       nmcli connection modify home connection.autoconnect (yes|no)
nmcli connection show home # lots of output piped through more

By including the security field in the nmcli -g scan,
nmcli tells us which sids are public, wep, or wpa2.
You can connect to a public ssid by either iw or nmcli,
but for consistency I recommend nmcli.
The latter puts it in your database of connections with a handy nickname.

iw dev wlan0 connect public_ssid
iw dev wlan0 disconnect # when done
nmcli device wifi connect public_ssid name McDonalds
nmcli connection down McDonalds # when done

wep security is easy, but hardly ever used.
Wireless lans tend to be public or wpa2.
Just for informational purposes, here is the syntax for wep.

iw dev wlan0 connect network_ssid key 0:[WEP key]
nmcli device wifi connect network_ssid password my_Password # as before

Unfortunately wpa2 is more complicated,
and the iw tool isn't sufficient.
For now let's say Bob set it up for you, or you used raspi-config,
or you used nmcli as shown above.

There is obviously some sort of connection database, but where is it?
Answer: /etc/NetworkManager/system-connections
There is one file per connection, and it's text based, and easy to read and understand.
These files are permission 600, as they should be, since they contain wifi passwords.
It's a good idea to review the changes after each nmcli command,
so you can see exactly what happened.
If you feel brave, you can edit the file yourself, then nmcli connection reload.
But you have to know what you're doing.
I would only use the editor to change the password, or some other simple insitu update.

Suppose I didn't set a nickname at first connect, but wish I had.
The name of the connection is, by default, the ssid, which can be long and awkward.
I can issue these three commands, but when the second brings up the new connection,
and displaces the old, it could terminate my ssh session.
I can always ssh back in so that's not a show stopper.

nmcli connection clone original_name new_name # copy
nmcli connection up new_name # displaces the old, only one connection over wlan0
nmcli connection delete original_name

But there is a one line command that is simpler and won't drop your ssh session.

nmcli connection modify original_name connection.id new_name

Oddly enough, this does not rename the file, only changes the id inside.
You can mv original_name new_name for consistency if you like.
The names of the files don't seem to matter, only what's inside.

nmcli accepts unambiguous short versions of its arguments.
Thus nmcli con mod is the same as nmcli connection modify

Now, put your pi on your network, over ethernet, or through wifi.
If on ethernet, you can set up wifi later,
using the instructions given above.
I highly recommend this course of action;
you want access to your new computer before you start wrangling wifi.

How do you find your pi?
What is its ip address?
I have this alias in my .bashrc.
route -n to see if this subnet is valid for you.

alias ipsearch="nmap -sn 10.0.0.0/24 | sed '/^Host/d'"

Run ipsearch >i1 before you boot up the pi, then ipsearch >i2 afterward.
diff i1 i2 should give you the address of the pi.
There's a chance other devices will come and go between
the two scans, but it's unlikely.
Edit /etc/hosts and associate the ip address with a convenient nickname for your new pi.
(This has no connection to the hostname.)
Now ssh nickname should get you in.
ssh will ask about adding to the known hosts etc, just say yes.

Note that your new pi over ethernet will have a different ip address from your new pi over wifi.
This is not surprising; the ethernet chip and the wifi chip have different 48-bit mac addresses,
hence the router will assign them different ip addresses, as per the dhcp protocol.
If you are in by ssh over ethernet, or your pi is already talking, and you then set up wifi,
you don't have to use the ipsearch trick to find the new wifi ip address.
Use ifconfig.
The eth0 paragraph gives the ip address over ethernet, if connected,
and the wlan0 paragraph gives the ip address over wifi, if connected.
The ether line shows the mac address, 6 bytes given in hex.

Some conventions can be helpful here.
Let's say my new pi's name is Eric Carmen.
Within /etc/hosts, eric (a convenient short nickname)
designates the ip address over ethernet,
while ericw, with a w at the end, designates the ip address over wifi.
Use ssh eric over ethernet, and ssh ericw over wifi.

Then there are functions with a similar nomenclature in my .bashrc.
This function syncs up a directory tree with its counterpart on eric,
over ethernet. Append w for the same function over wifi.

function synceric {
if [ $# = 0 ] ; then echo "missing arguments" ; return ; fi
rsync -avX --delete-after $1 eklhad@eric:/home/eklhad
}

Of course, if you never use ethernet, and use wifi exclusively,
as Bob has set up for you from the start,
then you don't need these conventions.

all right - you have found your new pi on the network, and are talking to it over ssh.
What's next?

There are several things you want to do, no matter what adapter you are using.
The first is an exchange of rsa keys.
You will be doing a lot of logging in, scp, even rsync,
to copy your personal files from the old computer to the new.
(Note: my comcast router does not allow telnet, rcp, or any insecure protocols,
even though it all takes place within my living room;
so I have to use ssh and the protocols that operate over ssh.)
You don't want to type in your password every time.
Go into your .ssh directory.
Do you have id_rsa and id_rsa.pub?
If yes then continue on to the next step.
If no then use ssh_keygen with no arguments to generate them.

Send the rsa files over to the new pi using scp.
Put them in .ssh, mirroring the source machine.
Note the permissions; ida_rsa must be 600. This is the private key.
On both machines, make sure authorized_keys is the same as id_rsa.pub.
You can copy the latter onto the former, or create a symbolic link.
Now you should be able to log in, or scp files, from either machine to the other,
without the hassle of passwords. Nice.

Remember that Bob provided a hostname for your pi.
If the name is not to your liking, edit /etc/hostname.
The new name takes effect after reboot.
My three pis are named Eric Carmen, Wally Bryson, and Dave Smalley.
Can you spot the pattern?
In /etc/hosts they are eric, wally, and dave - convenient nicknames.
Or ericw, wallyw, and davew, over wifi.

Set the root password,
sudo passwd
as discussed earlier.
Use su to test it, then exit to get back to your user account.

You may want to run in text mode, rather than in graphical mode.
You can't tell the difference over ssh, but it matters when you log in at the keyboard.
In the 1990's these were called run level 3 and run level 5.
Today we use systemctl.
You can determine the run mode by
systemctl get-default
It will say graphical or multiuser. It probably says graphical.
You can change it like this.
systemctl set-default multi-user.target
on the next reboot, the consoles will present a text based login,
and when you enter your login and password, you will be in the shell, just like ssh.
If you or Bob or anyone wants to go back to graphical on one of the consoles, type startx
That's all there is to it.
The other consoles remain in text mode.
You can switch between the consoles by alt-f1 through alt-f6

Because Bob was originally in graphical mode, there are several directories
in your home directory that you didn't create. Like Desktop.
remove these if you like.
But if you ever type startx to go back to graphical, these directories will reappear.

If you run text based, like I do, you probably have a .bash_login and .bashrc
that customize the shell just the way you like it.
Like PS1='$ ' instead of that long drawn-out prompt that takes forever to say.
Copy these files over to the new pi.
scp .bash_login .bashrc newmachine:
You don't have to reboot for these to take effect, simply log out and log back in again.
You may want to remove .profile; you're not using it any more.

When you log in for real, not over ssh, is your keyboard not as you expect?
Keys like " @ # \ are they in the wrong place?
It's hard to tell at this point, because your computer isn't talking yet.
You are still on ssh.
You'll find out eventually, and in the meantime,
let's check some important files.
Check /etc/default/keyboard.
In particular look for XKBLAYOUT.
Make sure it has the two letter country code you expect.
If it doesn't then change it.
Note that this time the code is lower case, whereas in the /boot/firmware/cmdline.txt file it was upper case.
As my old boss use to say,
"The great thing about standards is, there are so many of them."

Another important line in this file is XKBOPTIONS.
I set mine to ctrl:nocaps
This causes the caps lock to act like a third control key.
(speakup modules can interfere with this behavior, I'll talk about that later.)
I use control keys for speech functions about 20 times a minute,
and it would be a serious impairment if I had to reach all the way down to
Tierra del Fuego every time I wanted to activate control mode.
apparently I am not alone in this preference, since they made an option for this.
You have to reboot for these keyboard changes to take effect.

There are 6 consoles by default. That's not nearly enough.
I have to have 12, some people want 24.
Edit /etc/default/console-setup and look for the line
ACTIVE_CONSOLES
It is a glob pattern indicating 6 consoles. Change it to this.
ACTIVE_CONSOLES="/dev/tty[1-9] /dev/tty1[0-2]"
Write the file and quit.

This makes the consoles available but doesn't put a getty on them.
Use this command to check.
systemctl | fgrep getty@tty
On some systems you have 1 through 6; on some systems you only have 1.
There was only 1 active on bookworm.
Here is a command to bring in all the rest.
for i in 2 3 4 5 6 7 8 9 10 11 12 ; do systemctl enable getty@tty$i.service ; done
After the next reboot, all 12 consoles will be available.

There is probably a message that appears at each login, even over ssh.
A legal disclaimer of some sort.
This is in /etc/motd  which means message of the day.
This feature was part of the original unix in the late 1970's.
You can get rid of the message by removing the file. That's it.

There may be other actions upon login, that you do or do not want.
Check the files under /etc/issue.d.
If you don't want them, then mv /etc/issue.d /etc/issue.old

You will probably install dozens of packages as you go along;
I know I do. If apt install generates a lot of http 404 errors,
then apt is looking in the wrong place.
It's a good idea to sync your new Raspbian instance with the
package repositories by this command.

apt-get update

You will probably use git at some point; you probably did to clone this project.
git has about 287 features, and I know how to use 12 of them.
And it will probably remain so. I look at the manual and am somewhat overwhelmed.
But for my purposes, 12 is enough.

Setting up for git push can be counterintuitive.
You may want to git push some day, example, contributing to the edbrowse wiki,
which anyone with a github account can do.
The trick is the different protocols.
Clone using the https protocol, like this.

git clone https://github.com/edbrowse/acsint

Then look in .git/config, just to get comfortable with what is there.
It's only about 20 lines long.
You will see this same url.
But it's not set up for push.
If you ever need to push, then enter a command like this.

git remote set-url --push origin 'git@github.com:edbrowse/acsint.git'

Note that the protocol has changed.
You can try to push through an https url, but it won't work properly.
You have to use the git protocol.
Now go back into .git/config and notice that one line has been added.
pushurl = git@github.com:edbrowse/acsint.git
I could have done that myself using the editor,
and in fact I often do.
Just as I manage ~/.gitconfig with the editor.

To complete the github handshake, you have to give them your public key.
This is .ssh/id_rsa.pub, as described earlier.
You can limp along without it, but you'll be entering your password over and over and over again,
every time you do something with github, and it's exhausting.
With keys in place, and urls set up properly, you can get pull and git push
all day long, and there's no trouble.

There's a convenient option on git commit, it's -a.
Commit all the changes You made.
You don't have to git add every file that you changed, then git commit.

If you want to run speakup, you will need to
apt install espeakup
espeakup is a stand alone program that turns text into speech
using the espeak-ng library.
Note that it does not use espeak, you don't even need that, it uses espeak-ng,
which is brought in by dependency.
The installation does some things under the covers by triggers.
It installs two modules, speakup and speakup_soft,
and it enables espeakup.service.
These modules intercept keystrokes and can be intrusive.
In particular, they glom onto the caps lock (now control) key, and the numpad.
That is why this package is never installed by default.
The casual debian user would have no clue what was happening.
I was confused as well, for quite some time.

If you want to run jupiter in combination with espeakup, you must also run
apt install espeakup, just as a speakup user might,
because jupiter needs espeakup as well.
But you don't want or need all the other speakup machinery,
so you must run:
systemctl disable espeakup.service ; rmmod speakup speakup_soft
If you don't do this, jupiter and speakup modules might glom onto the same keys,
with ambiguous results.
Either might speak, or maybe both; it could be confusing.
I have only known one person who ran both at the same time, successfully.
It wasn't me, so I can't say much more about that.

I am especially odd in that I run jupiter with an external hardware synthesizer,
and I don't think anybody else does that any more.
But I prefer it.
Still I want to have espeakup at the ready,
in case my hardware synth fails, or I am travelling.
My synthesizer, which was quite compact in the 1990's,
is three times the size of my pi, and requires another outlet.

Before we build jupiter, or run speakup or any other adapter for that matter,
let's test espeakup on its own. And let's test it with index markers too.
Just to be clear, you are still on the new pi over ssh, because it isn't talking yet.
But you need to hear espeakup on the new pi, along with speech from your
previously adapted computer.
So you'll need an extra set of headphones or speakers.
Plug the headphones into the new pi, then type `espeakup -a' over ssh.
You probably have to be you, not root, for reasons that are described in music+speech.txt.
Now type things in, anything you want.
When in the course of human events it becomes necessary for one people...
You should hear the words you type, after each return,
since the tty is still in cooked mode.
Note, the only way to break out of espeakup is by control c.
EOF won't do it.

If you don't hear anything, put both headphones on your ears and listen carefully;
the volume may be turned down low.
Use the amixer command to set the volume to 70%.
This will probably work but not guaranteed.

amixer -q set Master 70%

Now try again, the words should be clear and audible.

Now that it's talking, lets try some index markers.
These are markers that we send to espeakup in the train of speech,
and it returns them back to us as the words are spoken.
This provides real-time information on what it is speaking.
Every adapter needs this to track speech.
When you hit stop, whatever key that might be,
you want to be on the word it was just speaking, and the only way to accomplish
that is through index markers.
So have this file at the ready.
It has index markers built in.
I call it jungle.

Why don't you write me<mark name="65"> I'm out in the jungle<mark name="66"> I'm hungry<mark name="67"> to hear you;<mark name="68">
Send me a card<mark name="69"> I am waiting so hard<mark name="70"> to be near you.<mark name="71">

The command to try is now:

espeakup -a <jungle

The -a option tells espeakup to honor and return index markers.
As it speaks the words on the new pi, it prints the 7 index markers A through G.
Note that the marker numbers are the ascii codes for A through G.
In a perfect world, each index marker appears just after espeakup has spoken
the corresponding word. However there are some delays.
The letter goes through the far tty, then over ssh, then through your tty,
then your adapter takes a fraction of a second to recognize it
and speak it as a new character on screen.
So the markers might seem just a bit late but they should be pretty close.
If they all come streaming out at the beginning, that is a bug from the buster time period.
Hopefully that is fixed by the time you read this.
Hit ^c to break out, and try the test again, and again.
If you have a sighted friend, he will see the letters in sync with the words,
without the delay of your screen reader.

My DoubleTalk also returns these index markers, along with the other hardware
synthesizers on the market.
They are necessary for every adapted computer.

There is an interesting bug in espeakup, stil there as of bookworm.
In the jungle file, change the semicolon to a period.
That's what it's suppose to be anyways.
Now run the jungle test again.
The D marker does not appear. It goes right from C to E.
I don't know what kind of corner case induces this bug,
but I guess it doesn't cause too much trouble in adapted computers,
because nobody has reported it.

Now that espeakup is validated, let's build the jupiter linear adapter.
Make and install procedures are described in the users guide,
but I'll include them here, in a more concise, step-by-step fashion.
Let's say you are already in progs/acsint.

cd drivers
./keyconfigure </dev/tty1

This is a perl program that prepares the source file acsint.c
according to your keyboard layout.
If you change your keyboard layout, you have to go back to this point and start again.
Though I don't expect you'll ever need to do that.

This program has to run with a tty as stdin.
That is not the case over ssh, and for now, you are still over ssh.
The pi isn't talking yet.
Thus you need the redirection </dev/tty1

make

If certain linux header files are missing, then you don't have kernel headers installed.
apt install kernel-headers
At this point the modules should compile.

sudo make modules_install

At the end, it may say that depmod cannot run because a system file is missing.
Yet it works for me manually.

sudo depmod -a

If you need to build and install the modules again for any reason,
you don't need to run depmod again.
Once is enough.

Tell the system to load the acsint modules at boot time by putting
the word acsint in a file in the directory /etc/modules-load.d.
For example:
sudo echo acsint > /etc/modules-load.d/access.conf
reboot, and verify the modules are loaded by lsmod | fgrep acsint

There is no harm in running ttyclicks and acsint all the time,
whether you use Jupiter or not. They do not interfere with Speakup,
or other adapters, or other running programs.

You should also verify that /dev/acsint exists.
It should be created for you by udev when the acsint module is loaded.

You'll notice that ttyclicks generates clicks as output is sent to the screen.
This is exactly what it is suppose to do;
it is the primary function of the ttyclicks module (though it can be disabled
with a module parameter). This can be extremely helpful,
especially if your adapter is not running for any reason.
I can tell, by clicks alone, when the computer responds to a command,
and I can discern the quantity and format of that response,
without any speech or braille.

Unfortunately, the raspberry pi has no toggle speaker,
so this module doesn't do anything.
That is somewhat of a disappointment to me,
but the pi has so many wonderful advantages that I'm willing to live with it.
Or more accurately, live without it.

Jupiter has a -a (audio) parameter that simulates these clicks through the sound card,
but that misses the point.
If jupiter doesn't run, there are no clicks, no feedback,
which is what ttyclicks was designed to do.
Still, if all goes well, some people do like the clicks,
and the -a option makes that possible.

Now we are ready to build jupiter itself.
This is the majority of the adapter, which lives in user space.

cd jupiter
make

If it can't find the include file ao.h
sudo apt install libao-dev

sudo make install

This installs jupiter in /usr/local/bin.
If there are other users on your computer, injkey can be a security risk.
(You can read more about injkey in music+speech.txt.)
thus there is a separate target to install it.

sudo make injkey_install

Next, jupiter needs a speech synthesizer.
If you are using a hardware synth then attach it to your computer.
The pi has no serial port, so I use a usb serial converter.
This creates the device /dev/ttyUSB0.
That should be present by udev, assuming the converter is plugged in.

Morelikely, you will be using a software synth.
If so, you need to install it.
We already talked about installing espeakup,
and the need to move its modules and services out of the way.
There are other software synthesizers, e.g. festival,
although jupiter is not configured for those at this time.

apt install espeakup
systemctl stop espeakup.service
systemctl disable espeakup.service
rmmod speakup speakup_soft

Before you connect it to jupiter, test espeakup directly.
Run it as user, not root.

espeakup -a

Just type stuff in and listen to it talk in the speakers or headphones.
Type control c when done.

mkdir /etc/jupiter
mkfifo /etc/jupiter/fifo
cp sample.cfg /etc/jupiter/start.cfg

This makes my sample config file your jupiter config file.
That's probably not what you want but it's easier to edit something
that exists than to start from scratch.
So edit the file and put the speech commands where you want them on the keyboard.

Now you can bravely try the whole system.
You're still doing all this over ssh.

jupiter -d esp "|espeakup -a 2>/dev/null"

remember, this runs as you, not as root.
-d makes it a daemon, so it drops into the background and you get your
shell prompt right away.
The next test is
echo hello world >/etc/jupiter/fifo
It should say hello world.

Now, for the first time, you can pick up the keyboard on your new pi
and test the adapted computer.
You don't have to be on ssh any more.
Type some commands and listen to the output.
Hit some keys that are bound to speech functions, and read lines, words, and characters.

If this is satisfactory, edit or create the file /etc/rc.local.
Make sure it is executable.
Mine uses the DoubleTalk external speech synthesizer on the serial port.
Yours, based on espeakup, might look like this.
the devices mentioned herein should exist by udev.
The first line has to be this or it won't run.

#!/bin/sh -e
# Grant me access to the audio devices, control through timer
chmod 666 /dev/snd/[c-t]*
chmod 666 /dev/acsint /dev/vcsa
# permission under /var/log, so I can debug
touch /var/log/acslog ; chmod 666 /var/log/acslog
su -c 'XDG_RUNTIME_DIR=/run/user/1000 /usr/local/bin/jupiter -d esp "|espeakup -a 2>/dev/null"' your_login

Now you know what to do. Reboot and see if the computer says "Jupiter ready".
Log in, type some commands, review the output,
and tune the config file to your liking.
This will be an ongoing process.
Even 20 years later, I still make a change now and then,
to see if that dovetails better with my work flow.

edbrowse is a sister project within this organization, and you probably
found edbrowse first, then landed here by curiosity.
edbrowse and jupiter were designed to work together, to provide a line oriented experience.
However, hundreds of people use edbrowse, without an adapter (some sighted people find it useful),
or with a different screen reader, and that's fine by me.
However, the converse is probably not true.
If you use jupiter, you almost have to have edbrowse.
This is a linear adapter and it forces you into a command line mode;
in fact it is rather procrustean.
You really need edbrowse to function in this environment.
With this in mind, here is a brief step-by-step to install edbrowse.
This is, for me, a critical part of getting a fresh Raspberry pi up and running,
so I think it reasonably belongs here.
In fact, you may want to do this much earlier, perhaps as soon as you have an ssh connection.
Configuring the far computer will be easier with edbrowse at your command.

First, you need a directory under your home directory for programs.
In a modern computer this would be your folder of applications, or Apps.
That concept was unheard of in 1995, so I called my directory progs, for programs.
It is brief, and doesn't have any annoying capital letters or spaces.
Thus all my working software is in /home/eklhad/progs.
You may choose a different directory of course.

When you cloned acsint from github, did you put it in progs, or a similar location?
If not, perhaps you can simply move it.
I don't know - I've never tried.
It's probably best to clone projects into their intended location.
So - I'll assume acsint is cloned in the progs directory, and you want to do the same for edbrowse.

cd progs
git clone https://github.com/edbrowse/edbrowse.wiki
cd edbrowse.wiki
# everybody has permission to contribute to the wiki
git remote set-url --push origin 'git@github.com:edbrowse/edbrowse.wiki.git'
cd ..
git clone https://github.com/bellard/quickjs
cd quickjs ; make
# If you get a lot of atomic undefines:   make EXTRA_LIBS=-latomic
cd ..
git clone https://github.com/edbrowse/edbrowse
sudo apt install libreadline-dev libpcre2-dev libcurl4-openssl-dev libssl-dev
sudo apt install unixodbc unixodbc-dev libsqliteodbc
cd edbrowse/src ; make
ln -s `pwd`/edbrowse ~/bin # put edbrowse in your path

And that should just work.
I have a handy alias in .bashrc:

alias e="/home/eklhad/bin/edbrowse"

I can type `e filename' to edit a file, from the shell or within edbrowse,
the syntax is the same.

Yes, there is sudo make install, which puts edbrowse in /usr/local/bin,
a traditional location.
I don't do that because I sometimes compile and test and compile and test in rapid succession,
and I don't want to install with each iteration.
thus I always execute the latest, with debug prints and all.
That's probably my bias as a developer.
You may want to stick with the traditional install procedure,
and then put this alias in your .bashrc.

alias e="/usr/local/bin/edbrowse"

I am not so cavalier when it comes to jupiter.
If I always run the latest all the time, and I make a change that breaks speech,
then the computer is not talking,
and even a reboot will execute the same broken program, whence I am screwed.
Thus I retain the traditional distinction between the local copy of jupiter
that I just built, that is in test mode,
and the one that I installed, that I know works.

